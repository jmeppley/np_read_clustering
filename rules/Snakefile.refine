from Bio import SeqIO
import numpy, pandas, os
from scipy import stats
from snakemake import logger
from jme.jupy_tools.utils import BLAST_PLUS

# config
MM_SIGMA_CUTOFF = config.get('mm_sigma_cutoff', 800)  # length distribution width
MFRAC_CUTOFF = config.get('mfrac_cutoff', 90)


def get_subcluster_mcl_files(template):
    """ return a list of the mcl files to make for each good cluster """
    return [template.format(**locals()) \
            for group, cluster in get_pre_filtered_clusters()]


rule cluster_abc:
    """ generate hit -> query -> mfrac table for mfrac over cutoff """
    input:
        '{output_dir}/refine_lastal/group.{group}/cluster.{cluster}/cluster.{cluster}.self.m8.agg'
    output:
        '{output_dir}/refine_lastal/group.{group}/cluster.{cluster}/cluster.{cluster}.self.m8.gt{mfrac_cutoff}.abc'
    run: 
        from jme.jupy_tools.utils import BLAST_PLUS
        pandas.read_csv(str(input), sep='\t') \
            .query(f'mfrac >= {MFRAC_CUTOFF}') \
            .set_index(['query','hit']) \
            .mfrac \
            .to_csv(str(output), sep='\t', header=None)

rule agg_lastal_hits:
    input:
        '{output_dir}/refine_lastal/group.{group}/cluster.{cluster}/cluster.{cluster}.self.m8'
    output:
        '{output_dir}/refine_lastal/group.{group}/cluster.{cluster}/cluster.{cluster}.self.m8.agg'
    params:
        format=BLAST_PLUS
    script: 'aggregate_lastal_hits.py'

rule cluster_lastal:
    input: '{output_dir}/mcl_all/reads/group.{group}/cluster.{cluster}.fasta'
    output:
        '{output_dir}/refine_lastal/group.{group}/cluster.{cluster}/cluster.{cluster}.self.m8'
    params:
        dbd='{output_dir}/mcl_all/reads/ldb/group.{group}/cluster.{cluster}.ldb'
    threads: 10
    shell:
        """
        mkdir {params.dbd}
        lastdb -P {threads} {params.dbd}/lastdb {input}
        lastal -f blasttab+ -P {threads} {params.dbd}/lastal {input} > {output} 2> {output}.log
        """

def get_pre_filtered_clusters():

    # hack to process a single cluster
    if CLUSTER >= 0:
        logger.debug(f"skip checkpoint check and return cluster: {CLUSTER}")
        return [(GROUP, CLUSTER)]

    reads_dir = checkpoints.choose_clusters.get().output.reads

    # hack to process a single group
    if GROUP >= 0:
        logger.debug(f"run checkpoint check just on group: {GROUP}")
        clusters, = glob_wildcards(reads_dir + f"/group.{GROUP}/cluster.{{cluster}}.fasta")
        return [(GROUP,c) for c in clusters]

    groups, clusters, = glob_wildcards(reads_dir + "/group.{group}/cluster.{cluster}.fasta")
    return [(g,c) for g,c in zip(groups, clusters)]

checkpoint choose_clusters:
    """
    Go through mcl file. For each cluster:
      * find reads in window fasta files
      * check length distribution
      * if it passes, write out fasta file
    """
    input:
        mcl=f'{WORK_DIR}/mcl_all/all.I{MCL_I}.mcl',
        fasta=ALL_FASTA,
        read_lens=f'{WORK_DIR}/all.reads.lengths.tsv'
    output:
        reads=directory(f'{WORK_DIR}/mcl_all/reads'),
        stats=f'{WORK_DIR}/mcl_all/cluster_stats.tsv',
        #pdf=f'{WORK_DIR}/mcl_all/cluster_plots.pdf'
    params:
        sigma_cutoff=MM_SIGMA_CUTOFF,
    script: 'choose_mcl_all_clusters.py'
