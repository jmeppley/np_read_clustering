"""
Rules to polish a subcluster
"""

from Bio import SeqIO
import pandas, numpy

RACON_ITERS = config.get('racon_iters', 3)
MIN_Q = config.get('min_q', 9)

def get_polished_comparison_files():
    """ return a list of output files for the polishing step for all subclusters
    if GROUP is set (config['group']), only that group of clusters is processed """
    logger.debug("Getting output files from polishing")

    out_fnames = ['medaka.v.drafts.gene.lengths',
                  'medaka.v.drafts.m8.agg']
    return [(SUBCLUSTER_DIR_TEMPLATE + "/" + fname).format(**locals()) \
            for group, cluster in get_pre_filtered_clusters() \
            for subcluster in get_pre_filtered_subclusters(group, cluster) \
            for fname in out_fnames \
           ]

def named_comparison_inputs(wildcards):
    " return a namedlist of faa files from polishing drafts "
    from snakemake.io import Namedlist
    input_dict = {'medaka': f'{wildcards.prefix}/medaka.faa'}
    for i in range(RACON_ITERS + 1):
        input_dict[f'draft_{i}'] = f'{wildcards.prefix}/draft.{i}.faa'
    return Namedlist(fromdict=input_dict)

rule compare_genes:
    """ tabulate the number, mean length, and total AAs of predicted genes for each draft """
    input: named_comparison_inputs
    output: '{prefix}/medaka.v.drafts.gene.lengths'
    run:
        data = []
        names = []
        for name, faa_file in input.items():
            lengths = []
            for gene in SeqIO.parse(faa_file, 'fasta'):
                _, start, end, _ = gene.description.split("#", 3)
                lengths.append(int(end) - int(start))
            lengths = numpy.array(lengths)
            data.append(dict(mean=lengths.mean(),
                             max=lengths.max(),
                             min=lengths.min(),
                             median=numpy.median(lengths),
                             num=len(lengths),
                             total=lengths.sum()
                            ))
            names.append(name)
        stats = pandas.DataFrame(data, index=names)
        stats.sort_index().to_csv(str(output), sep='\t')            

rule agg_draft_hits:
    """ aggregate the lastal output by hit/query pairs to get a shorter summary table """
    input:
        '{prefix}/medaka.v.drafts.m8'
    output:
        '{prefix}/medaka.v.drafts.m8.agg'
    run: 
        from jme.jupy_tools.hit_tables import agg_hit_table, BLAST_PLUS
        agg_hit_table(str(input), format=BLAST_PLUS) \
                .to_csv(str(output), sep='\t', index=None)

rule compare_drafts:
    """ map polished seq agaisnt all the drafts """
    input: 
        final='{prefix}/medaka.fasta',
        drafts='{prefix}/drafts.fasta'
    output:
        '{prefix}/medaka.v.drafts.m8'
    threads: 10
    shell:
        """
        lastdb -P {threads} {input.final} {input.final}
        lastal -f blasttab+ -P {threads} {input.final} {input.drafts} > {output}
        """

rule collect_drafts:
    """ put all the drafts into a fasta file to compare with the final sequence """
    input: lambda w: [f"{w.prefix}/draft.{n}.fasta" for n in range(RACON_ITERS + 1)]
    output: '{prefix}/drafts.fasta'
    run:
        with open(str(output), 'wt') as fasta_out:
            for draft in input:
                for read in SeqIO.parse(str(draft), 'fasta'):
                    read.id = os.path.basename(draft)
                    fasta_out.write(read.format('fasta'))

rule minimap_4_reference:
    """ all v all to pick a ref read """
    input: '{prefix}/reads/subcluster.{subcluster}.fasta'
    output: '{prefix}/subcluster.{subcluster}/all.v.all.paf'
    threads: 10
    shell: 'minimap2 -t {threads} -x ava-ont {input} {input} > {output}'

rule pick_ref_from_paf:
    """ pippcks a ref read and splits fasta into 2 (ref and others) """
    input:
        paf='{prefix}/reads/subcluster.{subcluster}.fasta',
        fasta='{prefix}/subcluster.{subcluster}/all.v.all.paf'
    output:
        ref='{prefix}/subcluster.{subcluster}/draft.0.fasta',
        others='{prefix}/subcluster.{subcluster}/other_reads.fasta'
    script: 'pick_ref_from_paf.py'        

rule minimap_4_racon:
    input:
        draft=lambda w: f'{w.prefix}/subcluster.{w.subcluster}/draft.{int(w.racon_i) - 1}.fasta',
        reads='{prefix}/subcluster.{subcluster}/other_reads.fasta'
    output: "{prefix}/subcluster.{subcluster}/draft.{racon_i}.sam"
    threads: 10
    shell: 'minimap2 -t {threads} -ax map-ont {input.draft} {input.reads} > {output}'
        
rule racon_iter:
    input:
        draft=lambda w: f'{w.prefix}/subculster.{w.subcluster}/draft.{int(w.racon_i) - 1}.fasta',
        reads='{prefix}/subcluster.{subcluster}/other_reads.fasta',
        sam="{prefix}/subcluster.{subcluster}/draft.{racon_i}.sam"
    output: '{prefix}/subcluster.{subcluster}/draft.{racon_i}.fasta'
    conda: 'conda/polish.yaml'
    threads: 10
    shell: 'racon --include-unpolished \
                --quality-threshold={MIN_Q} \
                -t {threads} \
                {input.reads} {input.sam} {input.draft} \
                > {output}'

rule medaka:
    input:                                                                                       
        reads='{prefix}/subcluster.{subcluster}/other_reads.fasta',
        draft=lambda w: '{prefix}/subcluster.{subcluster}/draft.{racon_iters}.fasta' \
                            .format(racon_iters=RACON_ITERS, **w)
    output: '{prefix}/subcluster.{subcluster}/medaka.fasta'
    params:                                                                                      
        out_dir='{prefix}/subcluster.{subcluster}',
        model=config.get('MEDAKA_model', 'r941_min_high_g303')                                                          
    conda: 'conda/polish.yaml'
    threads: 10
    shell:                                                                                       
        'medaka_consensus -i {input.reads} -d {input.draft} '                                
        '-o {params.out_dir} -t {threads} -m {params.model}; '                                   
        'mv {params.out_dir}/consensus.fasta {output}'    
        
ruleorder: pick_ref_from_paf > racon_iter
