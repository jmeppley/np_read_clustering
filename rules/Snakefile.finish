SIGMA_CUTOFF = config.get('sigma_cutoff', 500)

def get_refining_mcls(w, as_dict=False):
    """ Find all the stats files for subcluster choosing (one for each kept
    cluster)

    Return a list if called from input, and dict for the python code
    """
    sc_mcls = \
        {cluster: f'{WORK_DIR}/refine_lastal/group.{group}/cluster.{cluster}/cluster.{cluster}.self.m8.gt{MFRAC_CUTOFF}.I{MCL_I}.mcl'
         for group, cluster in get_pre_filtered_clusters()}

    if as_dict:
        return sc_mcls
    return sc_mcls.values()


rule compile_report:
    """
    generate a short report with:
     * number of size windows
     * number of clusters (and # > 10 and number kept)
     * number of subclusters (and # > 10 and number kept)
     * number of polished seqs (with length stats)
     
    """
    input:
        pol_stats=f"{WORK_DIR}/final/polished.seqs.stats.tsv",
        mcl_stats=f'{WORK_DIR}/mcl_all/cluster_stats.tsv',
        sc_mcls=get_refining_mcls,
    params:
        min_cl_size=MIN_POL_READS + 1,
        sigma_cutoff=SIGMA_CUTOFF
    output:
        report=REPORT_FILE
    benchmark: REPORT_FILE + ".time"
    script: "../scripts/compile_report.py"


rule compile_final_seqs:
    """
    Collect polished sequences and stats
    """
    input: lambda w: get_polished_comparison_files(kind='gene')
    output:
        fasta=f"{WORK_DIR}/final/polished.seqs.fasta",
        faa=f"{WORK_DIR}/final/polished.seqs.faa",
        stats=f"{WORK_DIR}/final/polished.seqs.stats.tsv"
    benchmark: f"{WORK_DIR}/final/polished.seqs.stats.tsv.time"
    params:
        work_dir=WORK_DIR,
        name=NAME
    script: '../scripts/compile_final_seqs.py'
